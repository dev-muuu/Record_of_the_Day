# Chapt 10. 프로퍼티와 메서드

<aside>

    ✔️ **이니셜라이저** 
    → 자바에서 생성자, swift에서는 init()통해 이루어짐

    **인스턴스** 
    → 자바에서 객체, swift에서는 구조체 개념도 사용하기 때문에 객체라고 통칭할 수 없어 인스턴스라고 표현

</aside>

## 프로퍼티

- 클래스, 구조체, 열거형 등에 관련된 값을 뜻함
- 인스턴스 프로퍼티와 타입 프로퍼티로 구분 가능
    
    → 타입 프로퍼티를 제외한 프로퍼티는 인스턴스 프로퍼티로 구분 가능
    
    - 인스턴스 프로퍼티
        
        → 인스턴스를 새로 생성할 때마다 초깃값에 해당하는 값이 프로퍼티의 값
        
        → 인스턴스마다 다른 값을 지닐 수 있음
        

### # 저장 프로퍼티

- 인스턴스의 변수 또는 상수
- 클래스와 구조체에서만 사용 가능
- 인스턴스 생성할 때 프로퍼티에 값이 필요없다면, 옵셔널로 선언 가능
→ 옵셔널로 선언하지 않으면, 반드시 초기값 필요

```swift
struct CoordinatePoint{
    var x: Int
    var y: Int  //x,y가 저장 프로퍼티
}

let myPointStruct: CoordinatePoint = CoordinatePoint(x: 1, y: 2)
print(myPointStruct) //CoordinatePoint(x: 1, y: 2) 출력
```

<aside>

    💡  > 구조체(struct)는 전체 저장 프로퍼티에 대해 이니셜라이저(initializer) 기본으로 제공 

    → 따로 생성할 필요 없음

</aside>

```swift
struct CoordinatePoint2{
    var x: Int = 0
    var y: Int = 0 //x,y가 저장 프로퍼티에 대해 초기값 설정 상황
}

let myPointStruct1: CoordinatePoint2 = CoordinatePoint2()
print(myPointStruct1) //CoordinatePoint2(x: 0, y: 0) 출력

let myPointStruct2: CoordinatePoint2 = CoordinatePoint2(x: 1, y: 2)
print(myPointStruct2) //CoordinatePoint2(x: 1, y: 2) 출력
```

<aside>

    💡  > 프로퍼티의 초기값이 설정되어있는 경우, 이니셜라이저에 초기값 넘기지 않아도 됨

    → 만약 초기값을 이니셜라이저에 넘겨줄 경우, 초기값 대신 해당 값으로 프로퍼티 값이 변경된다.

</aside>

```swift
class Position{
    var town:String = "KOREA" //초기값 지정
    var point:CoordinatePoint
    var name:String? //옵셔널 타입
    
    //이니셜라이저 기본적으로 제공하지 않기 때문에, 직접 생성 작업 필요 
		//초기값 지정된 프로퍼티는 이니셜라이저에 포함하지 않아도 됨
    init(name: String, point: CoordinatePoint) {
        self.name = name
        self.point = point
    }
    
    //옵셔널 프로퍼티의 경우, 초기화가 반드시 필요한 것은 아님
    init(point: CoordinatePoint) {
        self.point = point
    }
}

let myPointClass: Position = Position(name: "syong", point: myPointStruct)  //이니셜라이저 호출 통한 인스턴스 생성
print(myPointClass.name) //Optional("syong") 출력
print(myPointClass.town) //KOREA 출력

let myPointClass2: Position = Position(point: myPointStruct)  //이니셜라이저 호출 통한 인스턴스 생성 -> 옵셔널 프로퍼티 제외
print(myPointClass2.point) //CoordinatePoint(x: 1, y: 2) 출력
```

<aside>

    💡  > 클래스(class)는 기본으로 제공하는 이니셜라이저가 없기 때문에, 프로퍼티 초기화 위해서는 직접 생성 작업 필요

    이때, 초기값이 지정된 프로퍼티는 이니셜라이저에 포함하지 않아도 되며,
    옵셔널 타입으로 선언된 프로퍼티는 이니셜라이저에 포함되어도, 안되어도 상관없다

</aside>

```swift
class Position2{
    var town:String = "KOREA"
}

let myPointClass3: Position2 = Position2()  //초기값 설정이 되어있기 때문에, 이니셜라이저에 초기값 넘겨주지 않아도 됨
print(myPointClass3.town) // KOREA 출력
```

<aside>
    
    💡  > 초기값이 설정된 프로퍼티로만 클래스가 구성되어 있는 경우, 
    클래스 내에 이니셜라이저 코드를 작성하지 않아도 됨

</aside>

### # 지연 저장 프로퍼티

- 필요할 때 값이 할당되는 프로퍼티
- 호출이 있어야 값 초기화 진행
- `lazy` 키워드 사용 통해 선언 가능
→ 프로퍼티 선언할 때, 초기화 코드 반드시 필요
- var 키워드를 사용해 선언가능
→ let 키워드로는 불가능
→ 상수는 인스턴스가 완전히 생성되기 전 초기화가 진행되기 때문에, 필요할 때 값을 할당하는 지연 프로퍼티의 목적에 부합하지 않기 때문

```swift
class Position3 {
    var town:String = "KOREA" //초기값 지정
    var name:String
    lazy var point:CoordinatePoint2 = CoordinatePoint2() //lazy 반드시 초기값 지정 필요
    
    init(name: String) {
        self.name = name
    }
}

```

### # 연산 프로퍼티

- 실제 값을 저장하는 프로퍼티가 아님
- 특정 상태에 따른 값을 연산하는 프로퍼티
- 접근자(get), 설정자(set)의 역할 수행 가능
- 메서드보다 프로퍼티가 간편하고, 직관적
- 쓰기 전용 상태로 구현할 수 없다는 단점 존재
- 하나의 프로퍼티에 접근자와 설정자가 모여있음
- 해당 프로퍼티가 어떤 역할을 하는지 조금 더 명확하게 표현 가능

```swift
struct CoordinatePoint{
    var x: Int
    var y: Int
    
    //연산 프로퍼티
    var oppositePoint: CoordinatePoint{
        
        get{    //접근자
            return CoordinatePoint(x: -x, y: -y)
        }
        
        set(opposite){  //설정자, 매개변수 이름을 직접 선언한 경우
            x = -opposite.x
            y = -opposite.y
        }
    }
}

var ssooya: CoordinatePoint = CoordinatePoint(x: 10, y: 20)
print(ssooya)   //CoordinatePoint(x: 10, y: 20)
print(ssooya.oppositePoint) //CoordinatePoint(x: -10, y: -20)

ssooya.oppositePoint = CoordinatePoint(x: 15, y: 10)
print(ssooya)   //CoordinatePoint(x: -15, y: -10)
```

```swift
struct CoordinatePoint2{
    var x: Int
    var y: Int
    
    //연산 프로퍼티
    var oppositePoint: CoordinatePoint{
        
        get{ 
						//접근자 반환 타입이 프로퍼티 타입과 동일하고,코드가 한 줄이라면 return 키워드 생략 가능
            return CoordinatePoint(x: -x, y: -y)
        }
        
        set{  //설정자 이름을 newValue로 사용하는 것이 관용적, 이 경우에는 매개변수 따로 표기X
            x = -newValue.x
            y = -newValue.y
        }
    }
}
```

<aside>

    💡 > 설정자의 매개변수 이름 직접 설정하거나, 기존 설정값인 newValue 사용하거나 2가지 방법 존재.

</aside>

```swift
struct CoordinatePoint3{
    var x: Int
    var y: Int
    
    //읽기 전용 연산 프로퍼티 (쓰기 전용 연산 프로퍼티는 불가능.)
    var oppositePoint: CoordinatePoint{
        
        get{
            CoordinatePoint(x: -x, y: -y)
        }
    }
}
```

<aside>

    💡  > 접근자의 반환 타입이 연산 프로퍼티와 동일하고, 접근자 내 코드 길이가 한 줄이라면 `return` 키워드 생략 가능

</aside>

### # 프로퍼티 감시자

- 프로퍼티의 값이 새로 할당될 때마다 호출
- 프로퍼티의 값이 변경됨에 따라 적절한 작업 취할 수 있음
    
    → 변경되는 값이 현재 값과 같더라도 호출
    
- 저장프로퍼티, 상속받은 저장 프로퍼티와 상속받은 연산 프로퍼티에 적용 가능
    
    → 연산 프로퍼티는 상속 받았을 때만 프로퍼티 재정의를 통해 프로퍼티 감시자 사용
    
    → 재정의가 일어나도, get, set 메서드와  같은 기존 연산 프로퍼티 기능도 동작함
    
- willSet 메서드
    - 프로퍼티 값이 변경되기 직전 호출
    - 변경될 값이 전달인자로 전달
    - newValue로 매개변수 이름 기본적으로 지정
- didSet 메서드
    - 프로퍼티 값이 변경된 직후 호출
    - 변경되기 전 값이 전달인자로 전달
    - oldValue로 매개변수 이름 기본적으로 지정

```swift
class Account{
    var credit: Int = 0{
        willSet{ //프로퍼티 값 변경되기 직전 호출
            print("잔액 \(credit)원에서 \(newValue)원으로 변경될 예정")
        }
        didSet{ //프로퍼티 값 변경 직후 호출
            print("잔액 \(oldValue)원에서 \(credit)원으로 변경됨")
        }
    }
    
    var dollarValue:Double{
        get{
            return Double(credit)/1000.0
        }
        set{
            credit = Int(newValue*1000)
            print("잔액을 \(newValue)달러로 변경 중입니다.")
        }
    }
}
let account:Account = Account()
account.credit = 1000   //'잔액 0원에서 1000로 변경될 예정 -> 잔액 0원에서 1000로 변경됨' 출력
```

```swift
class ForeignAccount: Account{
    override var dollarValue: Double{
        willSet{
            print("잔액이 \(dollarValue)달러에서 \(newValue)달러로 변경될 예정입니다.")
        }
        didSet{
            print("잔액이 \(oldValue)달러에서 \(dollarValue)달러로 변경되었습니다.")
        }
    }
}

let account1:ForeignAccount = ForeignAccount()
account1.credit = 1000  //'잔액 1000원에서 2000로 변경될 예정 -> 잔액 1000원에서 2000로 변경됨' 출력
account1.dollarValue = 2    //'잔액을 2.0달러로 변경 중입니다. 잔액이 1.0달러에서 2.0달러로 변경되었습니다.' 출력
```

<aside>

    💡  > 프로퍼티 감시자를 포함한 클래스를 상속받은 경우
    → 부모 클래스의 연산 프로퍼티 override 가능
    → 자식 클래스 내에서는 연산 프로퍼티에 대해서 프로퍼티 감시자 생성 가능하며, 연산 프로퍼티 그대로 사용 가능하다.

</aside>

### # 전역변수와 지역 변수

- 전역 변수와 지역변수에도 연산 프로퍼티와 프로퍼티 감시자 사용 가능

```swift
var wonInPocket: Int = 2000{
    willSet{
        print("\(wonInPocket) -> \(newValue)")
    }
    didSet{
        print("\(oldValue) -> \(wonInPocket)")
    }
}

var dollarInPocket: Double{
    get{
        return Double(wonInPocket)/1000.0
    }
    set{
        wonInPocket = Int(newValue * 1000.0)
    }
}
```

### # 타입 프로퍼티

- 각각의 인스턴스가 아닌 타입 자체에 속하는 프로퍼티
- 타입 자체에 영향을 미치는 프로퍼티
- 인스턴스 생성 여부와 상관없이 타입 프로퍼티의 값은 하나
    1. 그 타입의 모든 인스턴스가 공통으로 사용하는 값 
    → c언어 static constant
    2. 모든 인스턴스에서 공용으로 접근하고 값을 변경할 수 있는 변수 등을 정의할 때 유용
        
        → c언어 static 변수
        
- 종류
    - 저장 타입 프로퍼티
        - 변수 또는 상수로 선언 가능
        - 초깃갑 설정 반드시 필요
        - 지연 연산됨
            
            → 지연 저장 프로퍼티와 다르게, 다중 스레드 환경이더라도 단 한번만 초기화됨
            
            → lazy 키워드 사용X
            
    - 연산 타입 프로퍼티
        - 변수로만 선언 가능

```swift
class AClass{
    //저장 타입 프로퍼티
    static var typeProperty: Int = 0
    
    var instanceProperty: Int = 0{
        didSet{
            //Self.typeProperty는 AClass.typeProperty와 같은 표현
            Self.typeProperty = instanceProperty + 100
        }
    }
    
    //연산 타입 프로퍼티
    static var typeComputedProperty: Int{
        get{
            return typeProperty
        }
        set{
            typeProperty = newValue
        }
    }
}

AClass.typeProperty = 123 // 타입 프로퍼티는 인스턴스를 생성하지 않고도 사용 가능
```

```swift
//타입 프로퍼티 선언으로 Account 클래스 수정
class Account2{
    
    static let dollarExchangeRate: Double = 1000.0
    
    var credit:Int = 0
    
    var dollarValue:Double{
        get{
            return Double(credit)/Self.dollarExchangeRate
        }
        set{
            credit = Int(newValue * Self.dollarExchangeRate)
            print("잔액을 \(newValue)달러로 변경 중입니다.")
        }
    }
}
```

<aside>

    💡  > dollarExchangeRate는 인스턴스에 상관없이 공통으로 사용
    → 타입 프로퍼티 상수로 선언
    → 반대로 credit은 각 인스턴스마다 다른 값을 가지기 때문에 인스턴스 프로퍼티로 선언

</aside>